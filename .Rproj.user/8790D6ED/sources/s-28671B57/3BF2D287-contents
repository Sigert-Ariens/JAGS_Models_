#heavily based on kruschke's BernTwoMetropolis

# Use this program as a template for experimenting with the Metropolis
# algorithm applied to two parameters called theta1,theta2 defined on the 
# domain [0,1]x[0,1].

# Load the MASS package, which defines the mvrnorm function.
# If this "library" command balks, you must intall the MASS package:
#install.packages("MASS")
library(MASS)

# Specify the data, to be used in the likelihood function.
k1 = 6 ; n1 = 8 ; k2 = 2 ; n2 = 7
# Specify the prior constants
a1 = 2 ; b1 = 2 ; a2 = 2 ; b2 = 2
myData = c(k1,k2,n1,n2)
pri = c(a1,b1,a2,b2)

# Define the likelihood function.
# The input argument is a vector: theta = c( theta1 , theta2 )
likelihood = function( theta , data) {
	k1 = data[1] ; n1 = data[3] ; k2 = data[2] ; n2 = data[4]
	likelihood = ( choose(n1, k1) * theta[1]^k1 * (1-theta[1])^(n1-k1)
                 * choose(n2, k2) * theta[2]^k2 * (1-theta[2])^(n2-k2) )
	return( likelihood )
}

# Define the prior density function.
# The input argument is a vector: theta = c( theta1 , theta2 )
prior = function( theta, pri ) {
	# Here's a beta-beta prior:
	a1 = pri[1] ; b1 = pri[2] ; a2 = pri[3] ; b2 = pri[4]
	prior = dbeta( theta[1] , a1 , b1) * dbeta( theta[2] , a2 , b2) 
	return( prior )
}

# Define the relative probability of the target distribution, as a function 
# of theta.  The input argument is a vector: theta = c( theta1 , theta2 ). 
# For our purposes, the value returned is the UNnormalized posterior prob.
targetRelProb = function( theta , myData, pri ) { 
	if ( all( theta >= 0.0 ) & all( theta <= 1.0 ) ) {
		targetRelProbVal =  likelihood( theta , myData) * prior( theta , pri)
	} else {
		# This part is important so that the Metropolis algorithm
		# never accepts a jump to an invalid parameter value.
		targetRelProbVal = 0.0 
	}
	return( targetRelProbVal )
}

# Specify the length of the trajectory, i.e., the number of jumps to try.
trajLength = ceiling( 1000 / .9 ) # arbitrary large number
# Initialize the vector that will store the results.
trajectory = matrix( 0 , nrow=trajLength , ncol=2 )
# Specify where to start the trajectory
trajectory[1,] = c( 0.50 , 0.50 ) # arbitrary start values of the two param's
# Specify the burn-in period.
burnIn = ceiling( .1 * trajLength ) # arbitrary number
# Initialize accepted, rejected counters, just to monitor performance.
nAccepted = 0
nRejected = 0

# Specify the covariance matrix for multivariate normal proposal distribution.
nDim = 2 ; sd1 = .2 ; sd2 = .2
covarMat = matrix( c( sd1^2 , 0.00 , 0.00 , sd2^2 ) , nrow=nDim , ncol=nDim )

# Now generate the random walk. stepIdx is the step in the walk.
# Specify the seed, so the trajectory can be reproduced.
set.seed(47405)
for ( stepIdx in 1:(trajLength-1) ) {
	currentPosition = trajectory[stepIdx,]
	# Use the proposal distribution to generate a proposed jump.
	# The shape and variance of the proposal distribution can be changed
	# to whatever you think is appropriate for the target distribution.
	proposedJump = mvrnorm( n=1 , mu=rep(0,nDim), Sigma=covarMat )
	# Compute the probability of accepting the proposed jump.
	R = targetRelProb( currentPosition + proposedJump , myData, pri )	/ targetRelProb( currentPosition , myData, pri )
	probAccept = min( 1, R)
	# Generate a random uniform value from the interval [0,1] to
	# decide whether or not to accept the proposed jump.
	if ( runif(1) < probAccept ) {
		# accept the proposed jump
		trajectory[ stepIdx+1 , ] = currentPosition + proposedJump
		# increment the accepted counter, just to monitor performance
		if ( stepIdx > burnIn ) { nAccepted = nAccepted + 1 }
	} else {
		# reject the proposed jump, stay at current position
		trajectory[ stepIdx+1 , ] = currentPosition
		# increment the rejected counter, just to monitor performance
		if ( stepIdx > burnIn ) { nRejected = nRejected + 1 }
	}
}

# End of Metropolis algorithm.

#-----------------------------------------------------------------------
# Begin making inferences by using the sample generated by the
# Metropolis algorithm.

# Extract just the post-burnIn portion of the trajectory.
acceptedTraj = trajectory[ (burnIn+1) : dim(trajectory)[1] , ]

# Compute the mean of the accepted points.
meanTraj =  apply( acceptedTraj , 2 , mean )
# Compute the standard deviations of the accepted points.
sdTraj = apply( acceptedTraj , 2 , sd )

# Display the sampled points
par( pty="s" ) # makes plots in square axes.
plot( acceptedTraj , type = "o" , xlim = c(0,1) , xlab = bquote(theta[1]) ,
      ylim = c(0,1) , ylab = bquote(theta[2]) )
# Display means and rejected/accepted ratio in plot.
if ( meanTraj[1] > .5 ) { xpos = 0.0 ; xadj = 0.0
} else { xpos = 1.0 ; xadj = 1.0 }
if ( meanTraj[2] > .5 ) { ypos = 0.0 ; yadj = 0.0
} else { ypos = 1.0 ; yadj = 1.0 }
text( xpos , ypos ,	bquote(
	"M=" * .(signif(meanTraj[1],3)) * "," * .(signif(meanTraj[2],3))
	* "; " * N[pro] * "=" * .(dim(acceptedTraj)[1])
	* ", " * frac(N[acc],N[pro]) * "=" 
	* .(signif(nAccepted/dim(acceptedTraj)[1],3))
	) , adj=c(xadj,yadj) , cex=1.5  )


